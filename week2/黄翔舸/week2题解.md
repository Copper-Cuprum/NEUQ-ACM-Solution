week2

汉诺塔问题：

递归：

参考资料：

什么是汉诺塔呢：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

首先我们肯定是把上面n-1个盘子移动到柱子C上，然后把最大的一块放在B上，最后把C上的所有盘子移动到B上，由此我们得出表达式：
H⑴ = 1
H(n) = 2H(n-1）+1 (n>1）
那么我们很快就能得到H(n）的一般式：
H(n) = 2^n - 1 (n>0)
并且这种方法的确是最少次数的，证明非常简单，可以尝试从2个盘子的移动开始证，你可以试试。
进一步加深问题（解法原创_）：
假如现在每种大小的盘子都有两个，并且是相邻的，设盘子个数为2n，问：⑴假如不考虑相同大小盘子的上下要多少次移动，设移动次数为J(n）；⑵只要保证到最后B上的相同大小盘子顺序与A上时相同，需要多少次移动，设移动次数为K(n）。
⑴中的移动相当于是把前一个问题中的每个盘子多移动一次，也就是：
J(n) = 2H(n) = 2*（2^n - 1） = 2^(n+1）-2
在分析⑵之前
，我们来说明一个现象，假如A柱子上有两个大小相同的盘子，上面一个是黑色的，下面一个是白色的，我们把两个盘子移动到B上，需要两次，盘子顺序将变成黑的在下，白的在上，然后再把B上的盘子移动到C上，需要两次，盘子顺序将与A上时相同，由此我们归纳出当相邻两个盘子都移动偶数次时，盘子顺序将不变，否则上下颠倒。
现在回到最开始的问题，n个盘子移动，上方的n-1个盘子总移动次数为2H(n-1），所以上方n-1个盘子的移动次数必定为偶数次，最后一个盘子移动次数为1次。
讨论问题⑵，
综上两点，可以得出，要把A上2n个盘子移动到B上，首先可以得出上方的2n-2个盘子必定移动偶数次，所以顺序不变，移动次数为：
J(n-1） = 2^n-2
然后再移动倒数第二个盘子，移动次数为2J(n-1）+1 = 2^(n+1）-3，
最后移动最底下一个盘子，所以总的移动次数为：
K(n) = 2*（2J(n-1）+1）+1 = 2（2^(n+1）-3）+1 = 2^(n+2）-5
开天辟地的神勃拉玛（和中国的盘古差不多的神吧）在一个庙里留下了三根金刚石的棒，第一根上面套着64个圆的金片，最大的一个在底下，其余一个比一个小，依次叠上去，庙里的众僧不倦地把它们一个个地从这根棒搬到另一根棒上，规定可利用中间的一根棒作为帮助，但每次只能搬一个，而且大的不能放在小的上面。计算结果非常恐怖（移动圆片的次数）大约是1.84467440*10^19，众僧们即便是耗尽毕生精力也不可能完成金片的移动了。
算法介绍
其实算法非常简单，当盘子的个数为n时，移动的次数应等于2^n – 1（有兴趣的可以自己证明试试看）。后来一位美国学者发现一种出人意料的简单方法，只要轮流进行两步操作就可以了。首先把三根柱子按顺序排成品字型，把所有的圆盘按从大到小的顺序放在柱子A上，根据圆盘的数量确定柱子的排放顺序：若n为偶数，按顺时针方向依次摆放 A B C；
若n为奇数，按顺时针方向依次摆放 A C B。
⑴按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，即当n为偶数时，若圆盘1在柱子A，则把它移动到B；若圆盘1在柱子B，则把它移动到C；若圆盘1在柱子C，则把它移动到A。
⑵接着，把另外两根柱子上可以移动的圆盘移动到新的柱子上。即把非空柱子上的圆盘移动到空柱子上，当两根柱子都非空时，移动较小的圆盘。这一步没有明确规定移动哪个圆盘，你可能以为会有多种可能性，其实不然，可实施的行动是唯一的。
⑶反复进行⑴⑵操作，最后就能按规定完成汉诺塔的移动。
所以结果非常简单，就是按照移动规则向一个方向移动金片：
如3阶汉诺塔的移动：A→C,A→B,C→B,A→C,B→A,B→C,A→C

解题思路：如上述材料所分析的，首先汉诺塔是一个递归问题，且有一个思想很关键，即对于n个圆盘的移动，上面的n-1个圆盘需要翻转两次，从而使其上下与最初时的一致，最后移动一步最下面的盘子即可。

代码：

#include<iostream>
#include<cstring>//包含字符串的头文件

using namespace std;
int main()
{
	void han(int n, string a, string b, string c);//函数声明
	int n;
	cin >> n;
	string a, b, c;
	cin >> a >> b >> c;
	 han(n, a, b, c);


	return 0;
}
void han(int n, string a, string b, string c)//定义函数
{
	if (n == 1)
	{
		cout << a << "->" << c << endl;//如果n=1根据题意直接将其移到c即可
	}
	else//对于n个盘子，首先将n-1个盘子移动到b上（注意由于n=1是的定义是a到c的移动，所以在下面书写时要想a移动到b，应当是acb的书写）

​	       //接着执行最后一个盘子从a到c的移动

​           //完成后再将n-1个盘子移动上去即从b到c所以为bac

{
		han(n - 1, a, c, b);
		cout << a << "->" << c << endl;
		han(n - 1, b, a, c);
	}

}

7-2

分而治之：

分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。

### 输入格式：

输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：

```
Np v[1] v[2] ... v[Np]
```

其中 `Np` 是该方案中计划攻下的城市数量，后面的系列 `v[i]` 是计划攻下的城市编号。

### 输出格式：

对每一套方案，如果可行就输出`YES`，否则输出`NO`。

### 输入样例：

```in
10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 10
2 4
5
4 10 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2结尾无空行
```

### 输出样例：

```out
NO
YES
YES
NO
NO结尾无空行
```

解题思路：利用二维数组，将给出的两个城市标记，如给出的是1，3则将a[1][3】标记为true，利用bool函数，其余标记为0，即false。 但是因为有多组数据，每次筛选过后为了得到yes或者no的结果，都要将已经筛选过的连锁消除1，即将其变为0，那么就会对原数组产生影响，所以设vector一个空容器，并且先用memset函数将其初始化，并在循环初始，将v[i】[j】与a一一对应，从而达成不破坏原数据的目的，根据是否存在true来判断是否都孤立无援，输出。

#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

int n, m, a, b, k, cs[10010];
vector<int> v[10010];//创造一个新的容器

// 判断是否每个城市都已经孤立
// 如果全部孤立 返回true
//v[i].size()向量大小:
bool t1(int n) {
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < v[i].size(); j++) {
            // 孤立的城市 = 没被摧毁 且 没有连接的城市
            if (cs[i] == 0 && cs[v[i][j]] == 0) {
                return false;
            }
        }
    }
    return true;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> a >> b;
        v[a].push_back(b); //尾部插入数字b：
        v[b].push_back(a);//尾部插入数字a：
    }
    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        // cs[i] == 1 表示i号城市已被摧毁
        memset(cs, 0, sizeof(cs));
        cin >> k;
        for (int j = 0; j < k; j++) {
            cin >> a;
            cs[a] = 1; // 摧毁标记
        }
        if (t1(n) == true) {
            cout<<"YES"<<endl;
        }
        else {
            cout << "NO" << endl;
        }
    }

    return 0;

}

7-3

知识点：归并排序

给定你一个长度为 n 的整数数列。

请你使用归并排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

### 输入格式:

输入共两行，第一行包含整数 n(1≤n≤100000)。

第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

### 输出格式:

输出共一行，包含 n 个整数，表示排好序的数列。

### 输入样例:

```in
5
3 1 2 4 5结尾无空行
```

### 输出样例:

```out
1 2 3 4 5 
```

解题思路：

根据归并排序的思路，应当利用数组进行数据储存，并将分组的比较大小最后一次合并，期间要多次利用冒泡排序的函数调用，很费时间，且复杂度很高，所以可以用sort函数嘛，是吧。

排序合集参考：https://blog.csdn.net/qq_35344198/article/details/106857042?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163481046016780264087214%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163481046016780264087214&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106857042.pc_search_result_control_group&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187

#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int a[100000];
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	sort(a, a + n, less<int>());
	
	for (int i = 0; i < n; i++)
	
	{
		cout << a[i] << " ";
	}


	return 0;

}

