# 7-1 汉诺塔问题

## 题目

> 给定一个由n个圆盘组成的塔，这些圆盘按照大小递减的方式套在第一根桩柱上。现要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面。 

## 输入格式

> 输入由四行： 第一行是圆盘数量n(1<=n<=10); 第二行到第四行分别是三根桩柱的名字(字符串)，n个盘子套在第一根桩柱上。

## 输出格式

> 输出移动步骤，每行输出一步。

## 解题思路

> 讲解据该问题分成最简单三步：1、将最底部以外的圆盘（即n-1个圆盘）移动到三个桩柱中既不是目的桩柱也不是起始桩柱的额外桩柱上；2、将最底部圆盘移动到桩柱上；3、将最底部以外的圆盘（即n-1个圆盘）移动到目的桩柱。
>
> 即：
>
> ```
> void Han(int n,int s,int e)
> {
> 	if (n == 1)
> 	{
> 		cout << a[s] << "->" << a[e] << endl;
> 		return;
> 	}
> 	Han(n - 1, s, 3 - s - e);
> 	cout << a[s] << "->" << a[e] << endl;
> 	Han(n - 1, 3 - s - e, e);
> }
> ```

# 7-2 分而治之

## 题目

> 分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。 

## 输入格式

> 输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：
>
> ```
> Np v[1] v[2] ... v[Np]
> ```
>
> 其中 `Np` 是该方案中计划攻下的城市数量，后面的系列 `v[i]` 是计划攻下的城市编号。

## 输出格式

> 对每一套方案，如果可行就输出`YES`，否则输出`NO`。

## 解题思路

> 先将被占领城市标记，再对所有城市进行判断，若没有被占领，且与周围城市有道路连通，则判断不成立。运用二维数组（第一维被记录城市，第二位记录连通数量，数据记录联通城市）或者运用vector。
>
> 即：
>
> ```
> bool ifok(int n)
> {
> 	int i, j;
> 	for (i = 1; i <= n; i++)
> 	{
> 		for (j = 0; j < v[i].size(); j++)
> 		{
> 			if (city[i] == 0 && city[v[i][j]] == 0)
> 				return false;
> 		}
> 	}
> 	return true;
> }
> ```

# 7-3 归并排序

## 题目

> 知识点：归并排序
>
> 给定你一个长度为 n 的整数数列。
>
> 请你使用归并排序对这个数列按照从小到大进行排序。
>
> 并将排好序的数列按顺序输出。

## 输入格式

> 输入共两行，第一行包含整数 n(1≤n≤100000)。
>
> 第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

## 输出格式

> 输出共一行，包含 n 个整数，表示排好序的数列。

## 解题思路

> 不断将需要比较的数列尽可能二分直至不可再分，之后依照将两段数列有序合并成一段数列的算法进行排序。
>
> 二分算法：
>
> ```
> void number_sort(int a[], int l, int r)
> {
> 	if (l >= r) return;
> 	else
> 	{
> 		int mid = (r + l) / 2;
> 		number_sort(a, l, mid);
> 		number_sort(a, mid + 1, r);
> 		merge(a, l, mid, r);
> 	}
> }
> ```
>
> 排序算法：
>
> ```
> void merge(int a[], int l, int mid, int r)
> {
> 	int newa[100001], i, j, k;
> 	for (i = l; i <= r; i++)
> 		newa[i - l] = a[i];
> 	i = l, j = mid + 1;
> 	for (k = l; k <= r; k++)
> 	{
> 		if (i > mid)
> 		{
> 			a[k] = newa[j - l];
> 			j++;
> 		}
> 		else if (j > r)
> 		{
> 			a[k] = newa[i - l];
> 			i++;
> 		}
> 		else if (newa[i-l]<newa[j-l])
> 		{
> 			a[k] = newa[i - l];
> 			i++;
> 		}
> 		else
> 		{
> 			a[k] = newa[j - l];
> 			j++;
> 		}
> 	}
> }
> ```
>
> 





