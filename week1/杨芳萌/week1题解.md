##STRING设第i个模式串长度为l，枚举文本串的每一位，从这一位开始向后检查l位，若这l所形成的字符串与这个模式串相等，则说明完成了一次匹配时间复杂度 = n * strlen(文本串）* strlen(模式串) = 1e7##区间因为只需要分成两个区间且两个区间不相交，因此本质上就是找一个断点把这个序列分割开，使得分割后的两边每一边不同的数字数之和最大维护一个前缀数组 *head[i]* 记录从前往后数，即 1 ~ i 位有多少不同的数字同理维护一个后缀数组 *tail[i]* 记录从后往前数，即 1 ~  i 位有多少不同的数字然后枚举断点的位置 i ，找到使得两边和最大的位置即可和为 *head[i]+tail[i+1]* ##小步点（绘图略）一开始我们在原点O的位置，我们设圆心为 *(d,n)* 的圆圆心为Q，最下端的点为A； 圆心为 *(2d,0)* 的圆圆心为P，连接PQ，与圆P交于B则显然：当圆Q与x轴不相交的时候最短路径为 *O->A->B* 当圆Q与x轴相交的时候最短路径为 *O->Q->B*##分糖果每一个小孩可能收到上一个小孩的糖果数即为上一个小孩糖果数的因数，同理他所能传给下一位小孩的数量就是他拥有糖果数的因数所以用递归求这些所有的因数的个数和即可##找眼镜所有人站成了一个圈，我们可以把这个圈展开成为一个一维的线段。但由于圆圈是可以无限循环的，所以我们可以把这个线段复制几次（最少两次），就可以保证所有的邻接关系没有遗漏了，然后此时用取模运算来找到他原来的序号##恰早饭简单模拟分段函数：*ans = v,   t<=T**ans = v-t+T,     t>T*   